{"version":3,"sources":["../src/tracer.js"],"names":[],"mappings":";;;;;;;;;;AAAA;;;;AACA;;;;AACA;;IAAY,S;;AACZ;;IAAY,S;;AACZ;;IAAY,I;;;;;;;;AAEZ;;;;;;;;;;;IAWqB,M;;;;;;;;;AAEjB;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kCAkCU,I,EAAM,M,EAAQ;;AAuBpB;AACA,qBAAS,UAAU,EAAnB;AAvBA;;AAwBA,gBAAI,OAAO,OAAX,EAAoB;AAChB;AACA,oBAAI,UAAU,UAAU,OAAV,CAAkB,OAAO,OAAzB,CAAd;AACA,oBAAI,OAAO,UAAX,EAAuB;AACnB,2BAAO,UAAP,CAAkB,IAAlB,CAAuB,OAAvB;AACH,iBAFD,MAEO;AACH,2BAAO,UAAP,GAAoB,CAAC,OAAD,CAApB;AACH;AACD,uBAAO,OAAO,OAAd;AACH;AACD,mBAAO,KAAK,UAAL,CAAgB,IAAhB,EAAsB,MAAtB,CAAP;AACH;;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;+BA6BO,W,EAAa,M,EAAQ,O,EAAS;;AAuBjC;AACA,gBAAI,qCAAJ,EAAiC;AAC7B,8BAAc,YAAY,OAAZ,EAAd;AACH;AAzBD;;AA0BA,mBAAO,KAAK,OAAL,CAAa,WAAb,EAA0B,MAA1B,EAAkC,OAAlC,CAAP;AACH;;AAED;;;;;;;;;;;;;;;;;;;;;;;;;gCAsBQ,M,EAAQ,O,EAAS;AAqBrB,mBAAO,KAAK,QAAL,CAAc,MAAd,EAAsB,OAAtB,CAAP;AApBA;AAqBH;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;mCACW,I,EAAM,M,EAAQ;AACrB,mBAAO,KAAK,IAAZ;AACH;;AAED;;;;gCACQ,W,EAAa,M,EAAQ,O,EAAS,CACrC;;AAED;;;;iCACS,M,EAAQ,O,EAAS;AACtB,mBAAO,KAAK,WAAZ;AACH;;;;;;kBA5MgB,M","file":"tracer.js","sourcesContent":["import Span from './span';\nimport SpanContext from './span_context';\nimport * as Constants from './constants';\nimport * as Functions from './functions';\nimport * as Noop from './noop';\n\n/**\n * Tracer is the entry-point between the instrumentation API and the tracing\n * implementation.\n *\n * The default object acts as a no-op implementation.\n *\n * Note to implementators: derived classes can choose to directly implement the\n * methods in the \"OpenTracing API methods\" section, or optionally the subset of\n * underscore-prefixed methods to pick up the argument checking and handling\n * automatically from the base class.\n */\nexport default class Tracer {\n\n    // ---------------------------------------------------------------------- //\n    // OpenTracing API methods\n    // ---------------------------------------------------------------------- //\n\n    /**\n     * Starts and returns a new Span representing a logical unit of work.\n     *\n     * For example:\n     *\n     *     // Start a new (parentless) root Span:\n     *     var parent = Tracer.startSpan('DoWork');\n     *\n     *     // Start a new (child) Span:\n     *     var child = Tracer.startSpan('Subroutine', {\n     *         childOf: parent.context(),\n     *     });\n     *\n     * @param {string} name - the name of the operation.\n     * @param {object} [fields] - the fields to set on the newly created span.\n     * @param {string} [fields.operationName] - the name to use for the newly\n     *        created span. Required if called with a single argument.\n     * @param {SpanContext} [fields.childOf] - a parent SpanContext (or Span,\n     *        for convenience) that the newly-started span will be the child of\n     *        (per REFERENCE_CHILD_OF). If specified, `fields.references` must\n     *        be unspecified.\n     * @param {array} [fields.references] - an array of Reference instances,\n     *        each pointing to a causal parent SpanContext. If specified,\n     *        `fields.childOf` must be unspecified.\n     * @param {object} [fields.tags] - set of key-value pairs which will be set\n     *        as tags on the newly created Span. Ownership of the object is\n     *        passed to the created span for efficiency reasons (the caller\n     *        should not modify this object after calling startSpan).\n     * @param {number} [fields.startTime] - a manually specified start time for\n     *        the created Span object. The time should be specified in\n     *        milliseconds as Unix timestamp. Decimal value are supported\n     *        to represent time values with sub-millisecond accuracy.\n     * @return {Span} - a new Span object.\n     */\n    startSpan(name, fields) {\n        // Debug-only runtime checks on the arguments\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length > 2) {\n                throw new Error('Invalid number of arguments.');\n            }\n            if (typeof name !== 'string') {\n                throw new Error('argument expected to be a string');\n            }\n            if (name.length === 0) {\n                throw new Error('operation name cannot be length zero');\n            }\n            if (fields && fields.childOf && fields.references) {\n                throw new Error('At most one of `childOf` and ' +\n                        '`references` may be specified');\n            }\n            if (fields && fields.childOf && !(\n                        fields.childOf instanceof Span ||\n                        fields.childOf instanceof SpanContext)) {\n                throw new Error('childOf must be a Span or SpanContext instance');\n            }\n        }\n\n        // Convert fields.childOf to fields.references as needed.\n        fields = fields || {};\n        if (fields.childOf) {\n            // Convert from a Span or a SpanContext into a Reference.\n            let childOf = Functions.childOf(fields.childOf);\n            if (fields.references) {\n                fields.references.push(childOf);\n            } else {\n                fields.references = [childOf];\n            }\n            delete(fields.childOf);\n        }\n        return this._startSpan(name, fields);\n    }\n\n    /**\n     * Injects the given SpanContext instance for cross-process propagation\n     * within `carrier`. The expected type of `carrier` depends on the value of\n     * `format.\n     *\n     * OpenTracing defines a common set of `format` values (see\n     * FORMAT_TEXT_MAP, FORMAT_HTTP_HEADERS, and FORMAT_BINARY), and each has\n     * an expected carrier type.\n     *\n     * Consider this pseudocode example:\n     *\n     *     var clientSpan = ...;\n     *     ...\n     *     // Inject clientSpan into a text carrier.\n     *     var headersCarrier = {};\n     *     Tracer.inject(clientSpan.context(), Tracer.FORMAT_HTTP_HEADERS, headersCarrier);\n     *     // Incorporate the textCarrier into the outbound HTTP request header\n     *     // map.\n     *     Object.assign(outboundHTTPReq.headers, headersCarrier);\n     *     // ... send the httpReq\n     *\n     * @param  {SpanContext} spanContext - the SpanContext to inject into the\n     *         carrier object. As a convenience, a Span instance may be passed\n     *         in instead (in which case its .context() is used for the\n     *         inject()).\n     * @param  {string} format - the format of the carrier.\n     * @param  {any} carrier - see the documentation for the chosen `format`\n     *         for a description of the carrier object.\n     */\n    inject(spanContext, format, carrier) {\n        // Debug-only runtime checks on the arguments\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length !== 3) {\n                throw new Error('Invalid number of arguments.');\n            }\n            if (!(spanContext instanceof SpanContext || spanContext instanceof Span)) {\n                throw new Error('first argument must be a SpanContext or Span instance');\n            }\n            if (typeof format !== 'string') {\n                throw new Error(`format expected to be a string. Found: ${typeof format}`);\n            }\n            if (format === Constants.FORMAT_TEXT_MAP && typeof carrier !== 'object') {\n                throw new Error('Unexpected carrier object for FORMAT_TEXT_MAP');\n            }\n            if (format === Constants.FORMAT_HTTP_HEADERS && typeof carrier !== 'object') {\n                throw new Error('Unexpected carrier object for FORMAT_HTTP_HEADERS');\n            }\n            if (format === Constants.FORMAT_BINARY && typeof carrier !== 'object') {\n                throw new Error('Unexpected carrier object for FORMAT_BINARY');\n            }\n        }\n\n        // Allow the user to pass a Span instead of a SpanContext\n        if (spanContext instanceof Span) {\n            spanContext = spanContext.context();\n        }\n        return this._inject(spanContext, format, carrier);\n    }\n\n    /**\n     * Returns a SpanContext instance extracted from `carrier` in the given\n     * `format`.\n     *\n     * OpenTracing defines a common set of `format` values (see\n     * FORMAT_TEXT_MAP, FORMAT_HTTP_HEADERS, and FORMAT_BINARY), and each has\n     * an expected carrier type.\n     *\n     * Consider this pseudocode example:\n     *\n     *     // Use the inbound HTTP request's headers as a text map carrier.\n     *     var headersCarrier = inboundHTTPReq.headers;\n     *     var wireCtx = Tracer.extract(Tracer.FORMAT_HTTP_HEADERS, headersCarrier);\n     *     var serverSpan = Tracer.startSpan('...', { childOf : wireCtx });\n     *\n     * @param  {string} format - the format of the carrier.\n     * @param  {any} carrier - the type of the carrier object is determined by\n     *         the format.\n     * @return {SpanContext}\n     *         The extracted SpanContext, or null if no such SpanContext could\n     *         be found in `carrier`\n     */\n    extract(format, carrier) {\n        // Debug-only runtime checks on the arguments\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length !== 2) {\n                throw new Error('Invalid number of arguments.');\n            }\n            if (typeof format !== 'string' || !format.length) {\n                throw new Error('format is expected to be a string of non-zero length');\n            }\n            if (format === Constants.FORMAT_TEXT_MAP && !(typeof carrier === 'object')) {\n                throw new Error('Unexpected carrier object for FORMAT_TEXT_MAP');\n            }\n            if (format === Constants.FORMAT_HTTP_HEADERS && !(typeof carrier === 'object')) {\n                throw new Error('Unexpected carrier object for FORMAT_HTTP_HEADERS');\n            }\n            if (format === Constants.FORMAT_BINARY) {\n                if (carrier.buffer !== undefined && typeof carrier.buffer !== 'object') {\n                    throw new Error('Unexpected carrier object for FORMAT_BINARY');\n                }\n            }\n        }\n        return this._extract(format, carrier);\n    }\n\n    // ---------------------------------------------------------------------- //\n    // Derived classes can choose to implement the below\n    // ---------------------------------------------------------------------- //\n\n    // NOTE: the input to this method is *always* an associative array. The\n    // public-facing startSpan() method normalizes the arguments so that\n    // all N implementations do not need to worry about variations in the call\n    // signature.\n    //\n    // The default behavior returns a no-op span.\n    _startSpan(name, fields) {\n        return Noop.span;\n    }\n\n    // The default behavior is a no-op.\n    _inject(spanContext, format, carrier) {\n    }\n\n    // The default behavior is to return null.\n    _extract(format, carrier) {\n        return Noop.spanContext;\n    }\n}\n"]}