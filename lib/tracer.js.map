{"version":3,"sources":["../src/tracer.js"],"names":[],"mappings":";;;;;;;;;;AAAA;;;;AACA;;;;AACA;;;;AACA;;IAAY,S;;AACZ;;IAAY,I;;;;;;;;AAEZ;;;;;;;;;;;;;;;;;;;;;;;;;IAyBqB,M;;;;;;;;;AAEjB;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kCAqCU,Y,EAAc,M,EAAQ;;AAyB5B;AACA;AACA,gBAAI,UAAU,MAAV,KAAqB,CAAzB,EAA4B;AACxB,oBAAI,OAAO,YAAP,KAAwB,QAA5B,EAAsC;AAClC,6BAAS;AACL,uCAAgB;AADX,qBAAT;AAGH,iBAJD,MAIO;AACH,6BAAS,YAAT;AACH;AACJ,aARD,MAQO;AACH,uBAAO,aAAP,GAAuB,YAAvB;AACH;AApCD;;;AAiDA;AACA,gBAAI,OAAO,OAAX,EAAoB;AAChB;AACA,oBAAI,UAAU,KAAK,OAAL,CAAa,OAAO,OAApB,CAAd;AACA,oBAAI,OAAO,UAAX,EAAuB;AACnB,2BAAO,UAAP,CAAkB,IAAlB,CAAuB,OAAvB;AACH,iBAFD,MAEO;AACH,2BAAO,UAAP,GAAoB,CAAC,OAAD,CAApB;AACH;AACD,uBAAO,OAAO,OAAd;AACH;AACD,mBAAO,KAAK,UAAL,CAAgB,MAAhB,CAAP;AACH;;AAED;;;;;;;;;;gCAOQ,W,EAAa;AACjB;AACA,gBAAI,qCAAJ,EAAiC;AAC7B,8BAAc,YAAY,OAAZ,EAAd;AACH;AACD,mBAAO,KAAK,UAAL,CAAgB,UAAU,kBAA1B,EAA8C,WAA9C,CAAP;AACH;;AAED;;;;;;;;;;oCAOY,W,EAAa;AACrB;AACA,gBAAI,qCAAJ,EAAiC;AAC7B,8BAAc,YAAY,OAAZ,EAAd;AACH;AACD,mBAAO,KAAK,UAAL,CAAgB,UAAU,sBAA1B,EAAkD,WAAlD,CAAP;AACH;;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;+BA6BO,W,EAAa,M,EAAQ,O,EAAS;;AAuBjC;AACA,gBAAI,qCAAJ,EAAiC;AAC7B,8BAAc,YAAY,OAAZ,EAAd;AACH;AAzBD;;;AA2BA,mBAAO,KAAK,OAAL,CAAa,WAAb,EAA0B,MAA1B,EAAkC,OAAlC,CAAP;AACH;;AAED;;;;;;;;;;;;;;;;;;;;;;;;;gCAsBQ,M,EAAQ,O,EAAS;AAqBrB,mBAAO,KAAK,QAAL,CAAc,MAAd,EAAsB,OAAtB,CAAP;AApBA;AAqBH;;AAED;;;;;;;;;;;8BAQM,I,EAAM;;AAWR,iBAAK,MAAL,CAAY,IAAZ;AAVA;AAWH;;AAGD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;mCACW,M,EAAQ;AACf,mBAAO,KAAK,IAAZ;AACH;;AAED;;;;mCACW,I,EAAM,W,EAAa;AAC1B,mBAAO,wBAAc,IAAd,EAAoB,WAApB,CAAP;AACH;;AAED;;;;gCACQ,W,EAAa,M,EAAQ,O,EAAS,CACrC;;AAED;AACA;AACA;AACA;AACA;AACA;;;;iCACS,M,EAAQ,O,EAAS;AACtB,mBAAO,IAAP;AACH;;AAED;AACA;;;;+BACO,I,EAAM;AACT,gBAAI,IAAJ,EAAU;AACN,qBAAK,IAAL;AACH;AACJ;;;;;;kBAjTgB,M","file":"tracer.js","sourcesContent":["import Span from './span';\nimport SpanContext from './span_context';\nimport Reference from './reference';\nimport * as Constants from './constants';\nimport * as noop from './noop';\n\n/**\n * Tracer is the entry-point between the instrumentation API and the tracing\n * implementation.\n *\n * The default object acts as a no-op implementation.\n *\n * ### Note to implementators:\n *\n * An implementation should derive from Tracer. The base class provides\n * \"public\" methods such as `startSpan()` which do two things before calling\n * the a similarly named worker method (in this case, `_startSpan()`), which the\n * derived class is expected to implement. The base does two things before\n * calling the worker method:\n *\n * (1) It normalizes the arguments before passing the arguments along to the\n * derived class. This avoids all N implementations from having to re-implement\n * error-prone argument manipulation to support different call signatures.  For\n * example, `inject()` allows either a `Span` or a `SpanContext` to be passed to\n * the function; `_inject()` will always be passed a `SpanContext`.\n *\n * (2) It provides argument checking when run in debug mode.\n *\n * Derived classes, of course, can override the \"public\" methods directly if\n * desired.\n */\nexport default class Tracer {\n\n    // ---------------------------------------------------------------------- //\n    // OpenTracing API methods\n    // ---------------------------------------------------------------------- //\n\n    /**\n     * Starts and returns a new Span representing a logical unit of work.\n     *\n     * For example:\n     *\n     *     // Start a new (parentless) root Span:\n     *     var parent = Tracer.startSpan('DoWork');\n     *\n     *     // Start a new (child) Span:\n     *     var child = Tracer.startSpan('Subroutine', {\n     *         reference: Tracer.childOf(parent.context()),\n     *     });\n     *\n     * @param {string|object} nameOrFields - if the given argument is a\n     *        string, it is the name of the operation and the second `fields`\n     *        argument is optional. If it is an object, it is treated as the\n     *        fields argument and a second argument should not be provided.\n     * @param {object} [fields] - the fields to set on the newly created span.\n     * @param {string} [fields.operationName] - the name to use for the newly\n     *        created span. Required if called with a single argument.\n     * @param {SpanContext} [fields.childOf] - a parent SpanContext (or Span,\n     *        for convenience) that the newly-started span will be the child of\n     *        (per REFERENCE_CHILD_OF). If specified, `fields.references` must\n     *        be unspecified.\n     * @param {array} [fields.references] - an array of Reference instances,\n     *        each pointing to a causal parent SpanContext. If specified,\n     *        `fields.childOf` must be unspecified.\n     * @param {object} [fields.tags] - set of key-value pairs which will be set\n     *        as tags on the newly created Span. Ownership of the object is\n     *        passed to the created span for efficiency reasons (the caller\n     *        should not modify this object after calling startSpan).\n     * @param {number} [fields.startTime] - a manually specified start time for\n     *        the created Span object. The time should be specified in\n     *        milliseconds as Unix timestamp. Decimal value are supported\n     *        to represent time values with sub-millisecond accuracy.\n     * @return {Span} - a new Span object.\n     */\n    startSpan(nameOrFields, fields) {\n        // Debug-only runtime checks on the arguments\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length > 2) {\n                throw new Error('Invalid number of arguments.');\n            }\n            if (typeof nameOrFields !== 'string' && typeof nameOrFields !== 'object') {\n                throw new Error('argument expected to be a string or object');\n            }\n            if (typeof nameOrFields === 'string' && nameOrFields.length === 0) {\n                throw new Error('operation name cannot be length zero');\n            }\n            if (typeof nameOrFields === 'object') {\n                if (arguments.length !== 1) {\n                    throw new Error('Unexpected number of arguments');\n                }\n                if (nameOrFields === null) {\n                    throw new Error('fields should not be null');\n                }\n                if (!nameOrFields.operationName) {\n                    throw new Error('operationName is a required parameter');\n                }\n            }\n        }\n\n        // Normalize the argument so the implementation is always provided\n        // an associative array of fields.\n        if (arguments.length === 1) {\n            if (typeof nameOrFields === 'string') {\n                fields = {\n                    operationName : nameOrFields,\n                };\n            } else {\n                fields = nameOrFields;\n            }\n        } else {\n            fields.operationName = nameOrFields;\n        }\n        if (process.env.NODE_ENV === 'debug') {\n            if (fields.childOf && fields.references) {\n                throw new Error('At most one of `childOf` and ' +\n                        '`references` may be specified');\n            }\n            if (fields.childOf && !(\n                        fields.childOf instanceof Span ||\n                        fields.childOf instanceof SpanContext)) {\n                throw new Error('childOf must be a Span or SpanContext instance');\n            }\n        }\n\n        // Convert fields.childOf to fields.references as needed.\n        if (fields.childOf) {\n            // Convert from a Span or a SpanContext into a Reference.\n            let childOf = this.childOf(fields.childOf);\n            if (fields.references) {\n                fields.references.push(childOf);\n            } else {\n                fields.references = [childOf];\n            }\n            delete(fields.childOf);\n        }\n        return this._startSpan(fields);\n    }\n\n    /**\n     * Return a new REFERENCE_CHILD_OF reference.\n     *\n     * @param {SpanContext} spanContext - the parent SpanContext instance to\n     *        reference.\n     * @return a REFERENCE_CHILD_OF reference pointing to `spanContext`\n     */\n    childOf(spanContext) {\n        // Allow the user to pass a Span instead of a SpanContext\n        if (spanContext instanceof Span) {\n            spanContext = spanContext.context();\n        }\n        return this._reference(Constants.REFERENCE_CHILD_OF, spanContext);\n    }\n\n    /**\n     * Return a new REFERENCE_FOLLOWS_FROM reference.\n     *\n     * @param {SpanContext} spanContext - the parent SpanContext instance to\n     *        reference.\n     * @return a REFERENCE_FOLLOWS_FROM reference pointing to `spanContext`\n     */\n    followsFrom(spanContext) {\n        // Allow the user to pass a Span instead of a SpanContext\n        if (spanContext instanceof Span) {\n            spanContext = spanContext.context();\n        }\n        return this._reference(Constants.REFERENCE_FOLLOWS_FROM, spanContext);\n    }\n\n    /**\n     * Injects the given SpanContext instance for cross-process propagation\n     * within `carrier`. The expected type of `carrier` depends on the value of\n     * `format.\n     *\n     * OpenTracing defines a common set of `format` values (see\n     * FORMAT_TEXT_MAP, FORMAT_HTTP_HEADERS, and FORMAT_BINARY), and each has\n     * an expected carrier type.\n     *\n     * Consider this pseudocode example:\n     *\n     *     var clientSpan = ...;\n     *     ...\n     *     // Inject clientSpan into a text carrier.\n     *     var headersCarrier = {};\n     *     Tracer.inject(clientSpan.context(), Tracer.FORMAT_HTTP_HEADERS, headersCarrier);\n     *     // Incorporate the textCarrier into the outbound HTTP request header\n     *     // map.\n     *     Object.assign(outboundHTTPReq.headers, headersCarrier);\n     *     // ... send the httpReq\n     *\n     * @param  {SpanContext} spanContext - the SpanContext to inject into the\n     *         carrier object. As a convenience, a Span instance may be passed\n     *         in instead (in which case its .context() is used for the\n     *         inject()).\n     * @param  {string} format - the format of the carrier.\n     * @param  {any} carrier - see the documentation for the chosen `format`\n     *         for a description of the carrier object.\n     */\n    inject(spanContext, format, carrier) {\n        // Debug-only runtime checks on the arguments\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length !== 3) {\n                throw new Error('Invalid number of arguments.');\n            }\n            if (!(spanContext instanceof SpanContext || spanContext instanceof Span)) {\n                throw new Error('first argument must be a SpanContext or Span instance');\n            }\n            if (typeof format !== 'string') {\n                throw new Error(`format expected to be a string. Found: ${typeof format}`);\n            }\n            if (format === Constants.FORMAT_TEXT_MAP && typeof carrier !== 'object') {\n                throw new Error('Unexpected carrier object for FORMAT_TEXT_MAP');\n            }\n            if (format === Constants.FORMAT_HTTP_HEADERS && typeof carrier !== 'object') {\n                throw new Error('Unexpected carrier object for FORMAT_HTTP_HEADERS');\n            }\n            if (format === Constants.FORMAT_BINARY && typeof carrier !== 'object') {\n                throw new Error('Unexpected carrier object for FORMAT_BINARY');\n            }\n        }\n\n        // Allow the user to pass a Span instead of a SpanContext\n        if (spanContext instanceof Span) {\n            spanContext = spanContext.context();\n        }\n\n        return this._inject(spanContext, format, carrier);\n    }\n\n    /**\n     * Returns a SpanContext instance extracted from `carrier` in the given\n     * `format`.\n     *\n     * OpenTracing defines a common set of `format` values (see\n     * FORMAT_TEXT_MAP, FORMAT_HTTP_HEADERS, and FORMAT_BINARY), and each has\n     * an expected carrier type.\n     *\n     * Consider this pseudocode example:\n     *\n     *     // Use the inbound HTTP request's headers as a text map carrier.\n     *     var headersCarrier = inboundHTTPReq.headers;\n     *     var wireCtx = Tracer.extract(Tracer.FORMAT_HTTP_HEADERS, headersCarrier);\n     *     var serverSpan = Tracer.startSpan('...', { childOf : wireCtx });\n     *\n     * @param  {string} format - the format of the carrier.\n     * @param  {any} carrier - the type of the carrier object is determined by\n     *         the format.\n     * @return {SpanContext}\n     *         The extracted SpanContext, or null if no such SpanContext could\n     *         be found in `carrier`\n     */\n    extract(format, carrier) {\n        // Debug-only runtime checks on the arguments\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length !== 2) {\n                throw new Error('Invalid number of arguments.');\n            }\n            if (typeof format !== 'string' || !format.length) {\n                throw new Error('format is expected to be a string of non-zero length');\n            }\n            if (format === Constants.FORMAT_TEXT_MAP && !(typeof carrier === 'object')) {\n                throw new Error('Unexpected carrier object for FORMAT_TEXT_MAP');\n            }\n            if (format === Constants.FORMAT_HTTP_HEADERS && !(typeof carrier === 'object')) {\n                throw new Error('Unexpected carrier object for FORMAT_HTTP_HEADERS');\n            }\n            if (format === Constants.FORMAT_BINARY) {\n                if (carrier.buffer !== undefined && typeof carrier.buffer !== 'object') {\n                    throw new Error('Unexpected carrier object for FORMAT_BINARY');\n                }\n            }\n        }\n        return this._extract(format, carrier);\n    }\n\n    /**\n     * Request that any buffered or in-memory data is flushed out of the process.\n     *\n     * @param {function(err: objectg)} done - optional callback function with\n     *        the signature `function(err)` that will be called as soon as the\n     *        flush completes. `err` should be null or undefined if the flush\n     *        was successful.\n     */\n    flush(done) {\n        // Debug-only runtime checks on the arguments\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length > 1) {\n                throw new Error('Invalid number of arguments');\n            }\n            if (done !== undefined && typeof done !== 'function') {\n                throw new Error('callback expected to be a function');\n            }\n        }\n\n        this._flush(done);\n    }\n\n\n    // ---------------------------------------------------------------------- //\n    // Methods to be implemented by derived classes\n    // ---------------------------------------------------------------------- //\n\n    // NOTE: the input to this method is *always* an associative array. The\n    // public-facing startSpan() method normalizes the arguments so that\n    // all N implementations do not need to worry about variations in the call\n    // signature.\n    //\n    // The default behavior returns a no-op span.\n    _startSpan(fields) {\n        return noop.span;\n    }\n\n    // The default behavior returns a valid Reference of the given type\n    _reference(type, spanContext) {\n        return new Reference(type, spanContext);\n    }\n\n    // The default behavior is a no-op.\n    _inject(spanContext, format, carrier) {\n    }\n\n    // The default behavior is to return null.\n    //\n    // TODO: seems like this should this be returning a no-op SpanContext\n    // rather than the prior behavior of returning null. Otherwise the caller\n    // may need to add an if check in various places depending to handle the\n    // case where tracing is disabled / not initialized.\n    _extract(format, carrier) {\n        return null;\n    }\n\n    // The default implementation is a no-op that directly calls the callback,\n    // presuming one is provided.\n    _flush(done) {\n        if (done) {\n            done(null);\n        }\n    }\n}\n"]}